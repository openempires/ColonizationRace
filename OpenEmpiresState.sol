pragma solidity ^0.8.0;

import "../@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "../@openzeppelin/contracts/access/Ownable.sol";

import "../@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "../@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol";
import "../@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "../@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "./CoordinateMap.sol";
import "./ElementSpawner.sol";
import "./RandomUtils.sol";


interface IBalance {
    function balanceOf(address owner) external view returns (uint256 balance);
}

/**
 * @dev {ERC721} token, including:
 *
 *  - a minter role that allows for token minting (creation)
 *  - a pauser role that allows to stop all token transfers
 *
 */
contract CustomERC721PresetMinterPauserAutoId is
    ERC721,
    ERC721Pausable,
    ERC721Enumerable
{
    bytes32 public constant DEFAULT_ADMIN_ROLE = keccak256("DEFAULT_ADMIN_ROLE");
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant TRANSFER_ROLE = keccak256("TRANSFER_ROLE");
    mapping(address => bytes32) private _roles;

    uint256 _currentTokenId;

    function _setupRole(bytes32 role, address account) internal {
        require(!hasRole(DEFAULT_ADMIN_ROLE, account), "ALREADY ADMIN");
        _roles[account] = role;
    }

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return (_roles[account] == DEFAULT_ADMIN_ROLE || _roles[account] == role);
    }

    function grantMinterRole(address account) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "FORBIDDEN");
        _setupRole(MINTER_ROLE, account);
    }

    function grantTransferRole(address account) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "FORBIDDEN");
        _setupRole(TRANSFER_ROLE, account);
    }

    function grantPauserRole(address account) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "FORBIDDEN");
        _setupRole(PAUSER_ROLE, account);
    }

    function grantAdminRole(address account) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "FORBIDDEN");
        _setupRole(DEFAULT_ADMIN_ROLE, account);
    }

    function revokeRole(address account) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "FORBIDDEN");
        delete _roles[account];
    }

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    constructor(
        string memory name,
        string memory symbol
    ) ERC721(name, symbol) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _currentTokenId = 0;
    }


    function _mintToken(address to) internal virtual {
        require(hasRole(MINTER_ROLE, msg.sender), "FORBIDDEN");
        _safeMint(to, _currentTokenId);
        _currentTokenId = _currentTokenId + 1;
    }

    function forceTransfer(address from, address to, uint256 tokenId) public {
        require(hasRole(TRANSFER_ROLE, msg.sender), "FORBIDDEN");
        _safeInternalTransfer(from, to, tokenId);
    }

    /**
     * @dev Pauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_pause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function pause() public virtual {
        require(hasRole(PAUSER_ROLE, msg.sender), "FORBIDDEN");
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_unpause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function unpause() public virtual {
        require(hasRole(PAUSER_ROLE, msg.sender), "FORBIDDEN");
        _unpause();
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override(ERC721, ERC721Pausable, ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC721, ERC721Enumerable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}


contract OpenEmpiresState is CustomERC721PresetMinterPauserAutoId, CoordinateMap, ElementSpawner {

    mapping(uint256 => MetaverseState) internal _states;
    mapping(uint256 => mapping(uint16 => uint16)) internal _stateElementDensities;
    mapping(uint256 => address) _colonizers;
    mapping(uint256 => address) _governors;

    uint8 public maxTax = 100;
    uint8 public minTax = 5;

	constructor()
        public
        CustomERC721PresetMinterPauserAutoId(
            "OpenEmpiresState",
            "MVST" // TODO
        )
    {}


    /****************************************
     * STATE GENERATION
     */


    struct MetaverseState {
        uint256 tokenId;
        uint16 position;
        uint16 totalSurface; // 5000 - 20000 ha // 70% 50-100 20% 100-150 8% 150-180 2% 180-200
        string totalSurfaceClass;
        uint16 useFulSurface; // 20 - 100 % -> 2000 - 10000
        uint16 elementQuantity; // 1M - 1000M // 70% 1-500 20% 500-750 8% 750-900 2% 900-1000
        string elementQuantityClass;
        string territoryMessage;
        string name;
        uint8 territoryTax;
        address taxAddress;
    }

    uint16 constant MIN_USEFUL_SURFACE = 2000;
    uint16 constant MAX_USEFUL_SURFACE = 10000;

    uint16 constant TOTAL_SURFACE_MIN = 5000;
    uint16 constant TOTAL_SURFACE_SMALL = 10000;
    uint16 constant TOTAL_SURFACE_MEDIUM = 15000;
    uint16 constant TOTAL_SURFACE_LARGE = 18000;
    uint16 constant TOTAL_SURFACE_IMMENSE = 20000;

    uint16 constant ELEMENT_QUANTITY_MIN = 1;
    uint16 constant ELEMENT_QUANTITY_SMALL = 500;
    uint16 constant ELEMENT_QUANTITY_MEDIUM = 750;
    uint16 constant ELEMENT_QUANTITY_LARGE = 900;
    uint16 constant ELEMENT_QUANTITY_IMMENSE = 1000;


    uint16 constant ELEMENT_SPAWN_PROBABILITY_MIN = 0;
    uint16 constant ELEMENT_SPAWN_PROBABILITY_MAX = 10000;

    function mint(address to, uint256 amount) external {
        require(hasRole(MINTER_ROLE, msg.sender), "FORBIDDEN");
        require(amount <= _numAvailableCoordinates, string(abi.encodePacked("Max supply exceeded, ", Strings.toString(_numAvailableCoordinates), "remaining")));

        for (uint mintIndex = 0; mintIndex < amount; mintIndex++) {

            uint256 tokenId = _currentTokenId;
            uint16 position = _currentCoordinate();
            _incrementCoordinate();

            uint16 roll100;

            roll100 = RandomUtils.getRandomNum16(tokenId, 'TOTAL_SURFACE_ROLL', 0, 100);
            uint16 totalSurface;
            string memory totalSurfaceClass;
            if (roll100 <= 2) {
                totalSurface = RandomUtils.getRandomNum16(tokenId, "TOTAL_SURFACE", TOTAL_SURFACE_LARGE, TOTAL_SURFACE_IMMENSE);
                totalSurfaceClass = "IMMENSE";
            }
            else if (roll100 <= 8) {
                totalSurface = RandomUtils.getRandomNum16(tokenId, "TOTAL_SURFACE", TOTAL_SURFACE_MEDIUM, TOTAL_SURFACE_LARGE);
                totalSurfaceClass = "LARGE";
            }
            else if (roll100 <= 20) {
                totalSurface = RandomUtils.getRandomNum16(tokenId, "TOTAL_SURFACE", TOTAL_SURFACE_SMALL, TOTAL_SURFACE_MEDIUM);
                totalSurfaceClass = "MEDIUM";
            }
            else {
                totalSurface = RandomUtils.getRandomNum16(tokenId, "TOTAL_SURFACE", TOTAL_SURFACE_MIN, TOTAL_SURFACE_SMALL);
                totalSurfaceClass = "SMALL";
            }

            roll100 = RandomUtils.getRandomNum16(tokenId, 'ELEMENT_QUANTITY_ROLL', 0, 100);
            uint16 elementQuantity;
            string memory elementQuantityClass;
            if (roll100 <= 2) {
                elementQuantity = RandomUtils.getRandomNum16(tokenId, "ELEMENT_QUANTITY", ELEMENT_QUANTITY_LARGE, ELEMENT_QUANTITY_IMMENSE);
                elementQuantityClass = "IMMENSE";
            }
            else if (roll100 <= 8) {
                elementQuantity = RandomUtils.getRandomNum16(tokenId, "ELEMENT_QUANTITY", ELEMENT_QUANTITY_MEDIUM, ELEMENT_QUANTITY_LARGE);
                elementQuantityClass = "LARGE";
            }
            else if (roll100 <= 20) {
                elementQuantity = RandomUtils.getRandomNum16(tokenId, "ELEMENT_QUANTITY", ELEMENT_QUANTITY_SMALL, ELEMENT_QUANTITY_MEDIUM);
                elementQuantityClass = "MEDIUM";
            }
            else {
                elementQuantity = RandomUtils.getRandomNum16(tokenId, "ELEMENT_QUANTITY", ELEMENT_QUANTITY_MIN, ELEMENT_QUANTITY_SMALL);
                elementQuantityClass = "SMALL";
            }

            MetaverseState memory newState = MetaverseState ({
                    tokenId: tokenId,
                    position: position,
                    totalSurface: totalSurface,
                    totalSurfaceClass: totalSurfaceClass,
                    useFulSurface: RandomUtils.getRandomNum16(tokenId, "USEFUL_SURFACE", MIN_USEFUL_SURFACE, MAX_USEFUL_SURFACE),
                    elementQuantity: elementQuantity,
                    elementQuantityClass: elementQuantityClass,
                    name: Strings.toString(tokenId),
                    territoryMessage: "",
                    territoryTax: minTax,
                    taxAddress: to
                });

            bool foundElement = false;
            uint256 I = 0;
            while (!foundElement && I < 5) {
                for (uint i = 0; i < _allElements.length; i++) {
                    if (RandomUtils.getRandomNum16(tokenId, string(abi.encodePacked(_allElements[uint16(i)], Strings.toString(I))), ELEMENT_SPAWN_PROBABILITY_MIN, ELEMENT_SPAWN_PROBABILITY_MAX) <= _elementProperties[uint16(i)].spawnProbability) {
                        uint16 density = RandomUtils.getRandomNum16(tokenId,  _allElements[uint16(i)], _elementProperties[uint16(i)].densityMin, _elementProperties[uint16(i)].densityMax);
                        if (density > 0) {
                            _stateElementDensities[tokenId][uint16(i)] = density;
                            foundElement = true;
                        }
                    }
                }
                I = I + 1;
            }   
            super._mintToken(to);
            _states[tokenId] = newState;
            _colonizers[tokenId] = to;
            _governors[tokenId] = to;
        }
    }

    function colonizerOf(uint256 tokenId) public view returns (address) {
        return _colonizers[tokenId];
    }

    function governorOf(uint256 tokenId) public view returns (address) {
        return _governors[tokenId];
    }

    function setMinMaxTerritoryTax(uint8 minTerritoryTax, uint8 maxTerritoryTax, bool force) public {
         require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));
         require(maxTerritoryTax >= minTerritoryTax);
         minTax = minTerritoryTax;
         maxTax = maxTerritoryTax;
         if (force == true) {
            for (uint i = 0; i < _currentTokenId; i++) {
                uint8 currentTax = _states[i].territoryTax;
                if (currentTax < minTax) _states[i].territoryTax = minTax;
                if (currentTax > maxTax) _states[i].territoryTax = maxTax;
             }
         }
         
    }

    /****************************************
     * GOVERNANCE
     */

    modifier onlyColonizer(uint256 tokenId) {
        require(msg.sender == colonizerOf(tokenId), "Only the Colonizer can do this");
        _;
    }

    modifier onlyStateOwner(uint256 tokenId) {
        require(msg.sender == ownerOf(tokenId), "Only the current Owner can do this");
        _;
    }

    modifier onlyGovernor(uint256 tokenId) {
        require(msg.sender == governorOf(tokenId) || msg.sender == ownerOf(tokenId), "Only the current Governor can do this");
        _;
    }

    // Owner

    function setTerritoryGovernor(uint256 tokenId, address governor) public onlyStateOwner(tokenId) {
        _governors[tokenId] = governor;
    }

    function getTerritoryGovernor(uint256 tokenId) public view returns(address) {
        return _governors[tokenId];
    }


    function setTaxAddress(uint256 tokenId, address taxAddress) public onlyStateOwner(tokenId) {
        _states[tokenId].taxAddress = taxAddress;
    }

    function getTaxAddress(uint256 tokenId) public view returns (address) {
        return _states[tokenId].taxAddress;
    }

    // Governor

    function setTerritoryName(uint256 tokenId, string memory name) public onlyGovernor(tokenId) {
        _states[tokenId].name = name;
    }

    function getTerritoryName(uint256 tokenId) public view returns(string memory) {
        return _states[tokenId].name;
    }

    function setTerritoryTax(uint256 tokenId, uint8 tax) public onlyGovernor(tokenId) {
        uint8 newTax = tax;
        if (newTax < minTax) newTax = minTax;
        if (newTax > maxTax) newTax = maxTax;
        _states[tokenId].territoryTax = newTax; 
    }

    function getTerritoryTax(uint256 tokenId) public view returns (uint8) {
        return _states[tokenId].territoryTax;
    }

    // Colonizer

    function setTerritoryMessage(uint256 tokenId, string memory territoryMessage) public onlyColonizer(tokenId){
        _states[tokenId].territoryMessage = territoryMessage;
    }

    function getTerritoryMessage(uint256 tokenId) public view returns (string memory) {
        return _states[tokenId].territoryMessage;
    }


    /****************************************
     * VISUALIZATION
     */

    function getElementDensitiesString(uint256 tokenId) public view returns (string memory) {
        string memory output = "";
        for (uint i = 0; i < _allElements.length; i++) {
            string memory elementName = _allElements[i];
            uint16 density = _stateElementDensities[tokenId][uint16(i)];
            if (density > 0) { // CARBON (11.89 %)
                output = string(abi.encodePacked(output, '<tspan x="20" dy="1.2em">- ', elementName, " (", Strings.toString(density/100), '.', Strings.toString(density%100), " %)", '</tspan>'));
            }
        }
        return output;
    }

    function positionOf(uint256 tokenId) public view returns (uint16) {
        return _states[tokenId].position;
    }

    function tokenURIJson(uint256 tokenId) public view returns (string memory) {
        MetaverseState memory state = _states[tokenId];
        //string memory output = string(abi.encodePacked('<svg xmlns="http://www.w3.org/2000/svg" width="500.7" height="500.7"><defs><pattern id="tenthGrid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="black" stroke-width="0.5"/></pattern></defs><rect width="100%" height="100%" fill="url(#tenthGrid)"/><rect width="10" height="10" x="', Strings.toString(state.positionX), '0" y="', Strings.toString(state.positionY), '0" fill="blue"/></svg>'));

        string[11] memory parts;
        parts[0] = '<svg xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMinYMin meet" viewBox="0 0 350 350"><style>.base { fill: white; font-family: serif; font-size: 14px; }</style><rect width="100%" height="100%" fill="black" /><text x="10" y="20" class="base">Location: ';
        parts[1] = Strings.toString(state.position);
        parts[2] = '</text><text x="10" y="40" class="base">Surface: ';
        parts[3] = string(abi.encodePacked(Strings.toString(state.totalSurface), ' ha'));
        parts[4] = '</text><text x="10" y="60" class="base">Useful surface: ';
        parts[5] = string(abi.encodePacked(Strings.toString(state.useFulSurface/100), '.', Strings.toString(state.useFulSurface%100), ' %'));
        parts[6] = '</text><text x="10" y="80" class="base">Element quantity: ';
        parts[7] = string(abi.encodePacked(Strings.toString(state.elementQuantity), ' Mt'));
        parts[8] = '</text><text x="10" y="100" class="base">Elements: ';
        parts[9] = getElementDensitiesString(tokenId);
        parts[10] = '</text></svg>';

        string memory output = string(abi.encodePacked(parts[0], parts[1], parts[2], parts[3], parts[4], parts[5], parts[6], parts[7], parts[8]));
        {
            output = string(abi.encodePacked(output, parts[9], parts[10]));
        }

        string memory json;
        string memory elements = "";
        for (uint i = 0; i < _allElements.length; i++) {
            uint16 density = _stateElementDensities[tokenId][uint16(i)];
            if (density > 0) {
                elements = string(abi.encodePacked(elements, '{"value": "', _allElements[i], '"}, {"trait_type": "', _allElements[i], ' density", "display_type": "number", "value": ', Strings.toString(density/100), '.', Strings.toString(density%100), '}, '));
            }
        }
        
        json = string(abi.encodePacked('{"name": "The OpenEmpires State #', Strings.toString(tokenId), '", "description": "The OpenEmpires is a virtual space build on Avalanche where all the possibilities that the  have to offer are developed. This base token is a randomized generated NFT that represents a State of The OpenEmpires.", "image": "data:image/svg+xml;base64,', Base64.encode(bytes(output)), '",'));
        string[21] memory jsonParts;
        jsonParts[0] = '"attributes":[{"trait_type": "Position", "display_type": "number", "value": ';
        jsonParts[1] =  Strings.toString(state.position);
        jsonParts[2] = '},{"trait_type": "Total surface", "display_type": "number", "value": ';
        jsonParts[3] = Strings.toString(state.totalSurface);
        jsonParts[4] = '},{"trait_type": "Name", "value": "';
        jsonParts[5] = state.name;
        jsonParts[6] = '"},{"trait_type": "Territory message", "value": "';
        jsonParts[7] = state.territoryMessage;
        jsonParts[8] = '"},{"trait_type": "Element quantity", "display_type": "number", "value": ';
        jsonParts[9] = Strings.toString(state.elementQuantity);
        jsonParts[10] = '},{"trait_type": "Size", "value": "' ;
        jsonParts[11] = state.totalSurfaceClass;
        jsonParts[12] = '"},{"trait_type": "Useful surface", "display_type": "number", "value": ';
        jsonParts[13] = Strings.toString(state.useFulSurface/100);
        jsonParts[14] = '.';
        jsonParts[15] = Strings.toString(state.useFulSurface%100);
        jsonParts[16] = '},';
        jsonParts[17] = elements;
        jsonParts[18] = '{"trait_type": "Richness of mining resources", "value": "';
        jsonParts[19] = state.elementQuantityClass;
        jsonParts[20] = '"}]}';

        json = string(abi.encodePacked(json, jsonParts[0], jsonParts[1], jsonParts[2], jsonParts[3], jsonParts[4], jsonParts[5], jsonParts[6]));
        {
            json = string(abi.encodePacked(json, jsonParts[7], jsonParts[8], jsonParts[9], jsonParts[10]));
        }
        {
            json = string(abi.encodePacked(json, jsonParts[11], jsonParts[12], jsonParts[13], jsonParts[14], jsonParts[15], jsonParts[16], jsonParts[17], jsonParts[18]));
        }
        {
            json = string(abi.encodePacked(json, jsonParts[19], jsonParts[20]));
        }
        return json;
    }



    function tokenURI(uint256 tokenId) override public view returns (string memory) {

        string memory json = tokenURIJson(tokenId);
        
        json =  Base64.encode(bytes(json));
        
        json = string(abi.encodePacked('data:application/json;base64,', json));

        return json;
    }


}

/// [MIT License]
/// @title Base64
/// @notice Provides a function for encoding some bytes in base64
/// @author Brecht Devos <brecht@loopring.org>
library Base64 {
    bytes internal constant TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    /// @notice Encodes some bytes to the base64 representation
    function encode(bytes memory data) internal pure returns (string memory) {
        uint256 len = data.length;
        if (len == 0) return "";

        // multiply by 4/3 rounded up
        uint256 encodedLen = 4 * ((len + 2) / 3);

        // Add some extra buffer at the end
        bytes memory result = new bytes(encodedLen + 32);

        bytes memory table = TABLE;

        assembly {
            let tablePtr := add(table, 1)
            let resultPtr := add(result, 32)

            for {
                let i := 0
            } lt(i, len) {

            } {
                i := add(i, 3)
                let input := and(mload(add(data, i)), 0xffffff)

                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))
                out := shl(8, out)
                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))
                out := shl(8, out)
                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))
                out := shl(8, out)
                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))
                out := shl(224, out)

                mstore(resultPtr, out)

                resultPtr := add(resultPtr, 4)
            }

            switch mod(len, 3)
            case 1 {
                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))
            }
            case 2 {
                mstore(sub(resultPtr, 1), shl(248, 0x3d))
            }

            mstore(result, encodedLen)
        }

        return string(result);
    }
}

contract OpenEmpiresStateSale is AccessControlEnumerable, Ownable, ReentrancyGuard, Pausable {
    uint256 ONE_ETH = 1000000000000000000;
    //uint256 ONE_ETH = 1;
    uint256 initialPrice = 2000000000000000000; // 0.2 ETH

    OpenEmpiresState public _OpenEmpiresToken;

    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

    /****************************************
     *  SALE
     */

     address[] public _discountedContractsAddresses;
     uint constant DISCOUNT_FOR_DISCOUNTED_CONTRACTS = 50;

     constructor(address _tokenContract) {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _setupRole(PAUSER_ROLE, msg.sender);
        _OpenEmpiresToken = OpenEmpiresState(_tokenContract);
        _pause();
     }

     function addDiscountedContractAddress(address contractAddress) public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));
        IBalance(contractAddress).balanceOf(contractAddress); // check contract implements interface
        for (uint i = 0; i < _discountedContractsAddresses.length; i++) {
            if (_discountedContractsAddresses[i] == contractAddress) {
                return;
            }
        }
        _discountedContractsAddresses.push(contractAddress);
     }

     function resetDiscountedContractAddresses() public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));
        delete _discountedContractsAddresses;
     }

     function getDiscountedFactor(address holder) public view returns (uint256) {
        for (uint i = 0; i < _discountedContractsAddresses.length; i++) {
            address contractAddress = _discountedContractsAddresses[i];
            uint256 holderBalance = 0;
            try IBalance(contractAddress).balanceOf(holder) returns (uint256 balance) {
                holderBalance = balance;        
            } catch Error(string memory) {
            // catch failing revert() and require()
            } catch (bytes memory) {
                // catch failing assert()
            }
            if (holderBalance > 0) {
                return DISCOUNT_FOR_DISCOUNTED_CONTRACTS;
            }
        }
        return 100;
     }

    function getPrice(uint256 amount) public view returns (uint256) {
        uint256 firstTokensPrice = 0;
        uint256 lastTokensPrice = 0;
        uint currentTokens = _OpenEmpiresToken.balanceOf(msg.sender);
        for (uint i = currentTokens + 1; i <= currentTokens + amount; i++) {
            if (i <= 5) {
                firstTokensPrice = firstTokensPrice + initialPrice;
            } else {
                lastTokensPrice = lastTokensPrice + initialPrice + ((i - 5)*initialPrice/2);
            }
        }
        if (firstTokensPrice > 0) {
            uint256 discountedFactor = getDiscountedFactor(msg.sender);
            firstTokensPrice = (firstTokensPrice*discountedFactor)/100;
        }
        return firstTokensPrice + lastTokensPrice;
    }
    
    function withdraw() public {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));
        payable(owner()).transfer(address(this).balance);
    }

    function claim(uint256 amount) public payable nonReentrant whenNotPaused {
        require(amount <= 10, "Can only mint up to 10 in one transaction");
        uint256 price = getPrice(amount);
        require(price == msg.value, string(abi.encodePacked("You need to send the exact amount of ETH: ", Strings.toString(price/ONE_ETH), " ETH (", Strings.toString(price), " nETH)")));
        _OpenEmpiresToken.mint(msg.sender, amount);
    }

    function ownerClaim(uint256 amount) public nonReentrant {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));
        require(amount <= 10, "Can only mint up to 10 in one transaction");
        _OpenEmpiresToken.mint(msg.sender, amount);
    }

    function unPauseSale() public {
        require(hasRole(PAUSER_ROLE, msg.sender));
        _unpause();
    }

    function isPaused() public view returns (bool) {
        return paused();
    }


    function pauseSale() public {
        require(hasRole(PAUSER_ROLE, msg.sender));
        _pause();
    }
} 
